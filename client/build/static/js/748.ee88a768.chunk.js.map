{"version":3,"file":"static/js/748.ee88a768.chunk.js","mappings":"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","sources":["../node_modules/retry/index.js","../node_modules/async-retry/lib/index.js","../node_modules/throttleit/index.js","../node_modules/retry/lib/retry.js","../node_modules/retry/lib/retry_operation.js","../node_modules/is-buffer/index.js","../node_modules/@vercel/blob/dist/stream-browser.js","../node_modules/@vercel/blob/dist/undici-browser.js","../node_modules/@vercel/blob/src/multipart/helpers.ts","../node_modules/@vercel/blob/src/bytes.ts","../node_modules/@vercel/blob/src/helpers.ts","../node_modules/is-node-process/src/index.ts","../node_modules/@vercel/blob/src/is-network-error.ts","../node_modules/@vercel/blob/src/debug.ts","../node_modules/@vercel/blob/src/fetch.ts","../node_modules/@vercel/blob/src/dom-exception.ts","../node_modules/@vercel/blob/src/xhr.ts","../node_modules/@vercel/blob/src/api.ts","../node_modules/@vercel/blob/src/request.ts","../node_modules/@vercel/blob/src/put-helpers.ts","../node_modules/@vercel/blob/src/multipart/complete.ts","../node_modules/@vercel/blob/src/multipart/create.ts","../node_modules/@vercel/blob/src/multipart/upload.ts","../node_modules/@vercel/blob/src/multipart/uncontrolled.ts","../node_modules/@vercel/blob/src/index.ts","../node_modules/@vercel/blob/src/put.ts","../node_modules/@vercel/blob/src/multipart/create-uploader.ts"],"sourcesContent":["module.exports = require('./lib/retry');","// Packages\nvar retrier = require('retry');\n\nfunction retry(fn, opts) {\n  function run(resolve, reject) {\n    var options = opts || {};\n    var op;\n\n    // Default `randomize` to true\n    if (!('randomize' in options)) {\n      options.randomize = true;\n    }\n\n    op = retrier.operation(options);\n\n    // We allow the user to abort retrying\n    // this makes sense in the cases where\n    // knowledge is obtained that retrying\n    // would be futile (e.g.: auth errors)\n\n    function bail(err) {\n      reject(err || new Error('Aborted'));\n    }\n\n    function onError(err, num) {\n      if (err.bail) {\n        bail(err);\n        return;\n      }\n\n      if (!op.retry(err)) {\n        reject(op.mainError());\n      } else if (options.onRetry) {\n        options.onRetry(err, num);\n      }\n    }\n\n    function runAttempt(num) {\n      var val;\n\n      try {\n        val = fn(bail, num);\n      } catch (err) {\n        onError(err, num);\n        return;\n      }\n\n      Promise.resolve(val)\n        .then(resolve)\n        .catch(function catchIt(err) {\n          onError(err, num);\n        });\n    }\n\n    op.attempt(runAttempt);\n  }\n\n  return new Promise(run);\n}\n\nmodule.exports = retry;\n","function throttle(function_, wait) {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError(`Expected the first argument to be a \\`function\\`, got \\`${typeof function_}\\`.`);\n\t}\n\n\t// TODO: Add `wait` validation too in the next major version.\n\n\tlet timeoutId;\n\tlet lastCallTime = 0;\n\n\treturn function throttled(...arguments_) { // eslint-disable-line func-names\n\t\tclearTimeout(timeoutId);\n\n\t\tconst now = Date.now();\n\t\tconst timeSinceLastCall = now - lastCallTime;\n\t\tconst delayForNextCall = wait - timeSinceLastCall;\n\n\t\tif (delayForNextCall <= 0) {\n\t\t\tlastCallTime = now;\n\t\t\tfunction_.apply(this, arguments_);\n\t\t} else {\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tlastCallTime = Date.now();\n\t\t\t\tfunction_.apply(this, arguments_);\n\t\t\t}, delayForNextCall);\n\t\t}\n\t};\n}\n\nmodule.exports = throttle;\n","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","// This file is here because Edge Functions have no support for Node.js streams by default\n// It's unlikely someone would try to read/use a Node.js stream in an Edge function but we still put\n// a message in case this happens\n\nexport const Readable = {\n  toWeb() {\n    throw new Error(\n      'Vercel Blob: Sorry, we cannot get a Readable stream in this environment. If you see this message please open an issue here: https://github.com/vercel/storage/ with details on your environment.',\n    );\n  },\n};\n","// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nexport const fetch = globalThis.fetch.bind(globalThis);\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport { Readable } from 'stream';\n// eslint-disable-next-line unicorn/prefer-node-protocol -- node:buffer does not resolve correctly in browser and edge\nimport type { Buffer } from 'buffer';\nimport isBuffer from 'is-buffer';\nimport type { PutBody } from '../put-helpers';\n\n/**\n * Input format for a multipart upload part.\n * Used internally for processing multipart uploads.\n */\nexport interface PartInput {\n  /**\n   * The part number (1-based index).\n   */\n  partNumber: number;\n\n  /**\n   * The content of the part.\n   */\n  blob: PutBody;\n}\n\n/**\n * Represents a single part of a multipart upload.\n * This structure is used when completing a multipart upload to specify the\n * uploaded parts and their order.\n */\nexport interface Part {\n  /**\n   * The ETag value returned when the part was uploaded.\n   * This value is used to verify the integrity of the uploaded part.\n   */\n  etag: string;\n\n  /**\n   * The part number of this part (1-based).\n   * This number is used to order the parts when completing the multipart upload.\n   */\n  partNumber: number;\n}\n\nconst supportsNewBlobFromArrayBuffer = new Promise<boolean>((resolve) => {\n  // React Native doesn't support creating a Blob from an ArrayBuffer, so we feature detect it\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob\n      .text()\n      .then((text) => {\n        resolve(text === 'hello');\n      })\n      .catch(() => {\n        resolve(false);\n      });\n  } catch {\n    resolve(false);\n  }\n});\n\nexport async function toReadableStream(\n  value: PutBody,\n): Promise<ReadableStream<ArrayBuffer | Uint8Array>> {\n  // Already a ReadableStream, nothing to do\n  if (value instanceof ReadableStream) {\n    return value as ReadableStream<ArrayBuffer>;\n  }\n\n  // In the case of a Blob or File (which inherits from Blob), we could use .slice() to create pointers\n  // to the original data instead of loading data in memory gradually.\n  // Here's an explanation on this subject: https://stackoverflow.com/a/24834417\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n\n  if (isNodeJsReadableStream(value)) {\n    return Readable.toWeb(value) as ReadableStream<ArrayBuffer>;\n  }\n\n  let streamValue: Uint8Array;\n\n  // While ArrayBuffer is valid as a fetch body, when used in a ReadableStream it will fail in Node.js with\n  // The \"chunk\" argument must be of type string or an instance of Buffer or Uint8Array. Received an instance of ArrayBuffer\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    // value is a string, we need to convert it to a Uint8Array to get create a stream from it\n    streamValue = stringToUint8Array(value as string);\n  }\n\n  // This line ensures that even when we get a buffer of 70MB, we'll create a stream out of it so we can have\n  // better progress indication during uploads\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n\n  // from https://github.com/sindresorhus/to-readable-stream/blob/main/index.js\n  return new ReadableStream<ArrayBuffer | Uint8Array>({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    },\n  });\n}\n\n// From https://github.com/sindresorhus/is-stream/\nexport function isNodeJsReadableStream(value: PutBody): value is Readable {\n  return (\n    typeof value === 'object' &&\n    typeof (value as Readable).pipe === 'function' &&\n    (value as Readable).readable &&\n    typeof (value as Readable)._read === 'function' &&\n    // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === 'object'\n  );\n}\n\nfunction stringToUint8Array(s: string): Uint8Array {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\n\nfunction isNodeJsBuffer(value: PutBody): value is Buffer {\n  return isBuffer(value);\n}\n","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n// from https://github.com/visionmedia/bytes.js/blob/master/index.js\n// had too many issues with bundling: https://github.com/vercel/storage/issues/818\ntype ByteUnit = 'b' | 'kb' | 'mb' | 'gb' | 'tb' | 'pb';\n\ntype ByteUnitMap = {\n  readonly [_K in ByteUnit]: number;\n};\n\n// eslint-disable-next-line prefer-named-capture-group -- fine\nconst parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\n\nconst map: ByteUnitMap = {\n  b: 1,\n  // eslint-disable-next-line no-bitwise -- fine\n  kb: 1 << 10,\n  // eslint-disable-next-line no-bitwise -- fine\n  mb: 1 << 20,\n  // eslint-disable-next-line no-bitwise -- fine\n  gb: 1 << 30,\n  tb: Math.pow(1024, 4),\n  pb: Math.pow(1024, 5),\n};\n\nexport function bytes(val: string | number): number | null {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  const results = parseRegExp.exec(val);\n  let floatValue: number;\n  let unit: ByteUnit = 'b';\n\n  if (!results) {\n    floatValue = parseInt(val, 10);\n  } else {\n    const [, res, , , unitMatch] = results;\n    if (!res) {\n      return null;\n    }\n    floatValue = parseFloat(res);\n    if (unitMatch) {\n      unit = unitMatch.toLowerCase() as ByteUnit;\n    }\n  }\n\n  if (isNaN(floatValue)) {\n    return null;\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n","// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nimport type { Readable } from 'node:stream';\nimport type { RequestInit, Response } from 'undici';\nimport { isNodeProcess } from 'is-node-process';\nimport { isNodeJsReadableStream } from './multipart/helpers';\nimport type { PutBody } from './put-helpers';\n\nexport { bytes } from './bytes';\n\nconst defaultVercelBlobApiUrl = 'https://vercel.com/api/blob';\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n  /**\n   * `AbortSignal` to cancel the running request. See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  abortSignal?: AbortSignal;\n}\n\n// shared interface for put, copy and multipart upload\nexport interface CommonCreateBlobOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. The only currently allowed value is `public`.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue false\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Allow overwriting an existing blob. By default this is set to false and will throw an error if the blob already exists.\n   * @defaultvalue false\n   */\n  allowOverwrite?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The minimum is 1 minute. There's no maximum but keep in mind that browser and edge caches will do a best effort to respect this value.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 30 * 24 * 60 * 60 (1 Month)\n   */\n  cacheControlMaxAge?: number;\n}\n\n/**\n * Event object passed to the onUploadProgress callback.\n */\nexport interface UploadProgressEvent {\n  /**\n   * The number of bytes uploaded.\n   */\n  loaded: number;\n\n  /**\n   * The total number of bytes to upload.\n   */\n  total: number;\n\n  /**\n   * The percentage of the upload that has been completed.\n   */\n  percentage: number;\n}\n\n/**\n * Callback type for tracking upload progress.\n */\nexport type OnUploadProgressCallback = (\n  progressEvent: UploadProgressEvent,\n) => void;\n\nexport type InternalOnUploadProgressCallback = (loaded: number) => void;\n\nexport type BlobRequestInit = Omit<RequestInit, 'body'> & { body?: PutBody };\n\nexport type BlobRequest = ({\n  input,\n  init,\n  onUploadProgress,\n}: {\n  input: string | URL;\n  init: BlobRequestInit;\n  onUploadProgress?: InternalOnUploadProgressCallback;\n}) => Promise<Response>;\n\n/**\n * Interface for including upload progress tracking capabilities.\n */\nexport interface WithUploadProgress {\n  /**\n   * Callback to track the upload progress. You will receive an object with the following properties:\n   * - `loaded`: The number of bytes uploaded\n   * - `total`: The total number of bytes to upload\n   * - `percentage`: The percentage of the upload that has been completed\n   */\n  onUploadProgress?: OnUploadProgressCallback;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\n/**\n * Generates a download URL for a blob.\n * The download URL includes a ?download=1 parameter which causes browsers to download\n * the file instead of displaying it inline.\n *\n * @param blobUrl - The URL of the blob to generate a download URL for\n * @returns A string containing the download URL with the download parameter appended\n */\nexport function getDownloadUrl(blobUrl: string): string {\n  const url = new URL(blobUrl);\n\n  url.searchParams.set('download', '1');\n\n  return url.toString();\n}\n\n// Extracted from https://github.com/sindresorhus/is-plain-obj/blob/main/index.js\n// It's just nearly impossible to use ESM modules with our current setup\nexport function isPlainObject(value: unknown): boolean {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ok\n  const prototype = Object.getPrototypeOf(value);\n  return (\n    (prototype === null ||\n      prototype === Object.prototype ||\n      Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) &&\n    !(Symbol.iterator in value)\n  );\n}\n\nexport const disallowedPathnameCharacters = ['//'];\n\n// Chrome: implemented https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests\n// Microsoft Edge: implemented (Chromium)\n// Firefox: not implemented, BOO!! https://bugzilla.mozilla.org/show_bug.cgi?id=1469359\n// Safari: not implemented, BOO!! https://github.com/WebKit/standards-positions/issues/24\nexport const supportsRequestStreams = (() => {\n  // The next line is mostly for Node.js 16 to avoid trying to do new Request() as it's not supported\n  // TODO: Can be removed when Node.js 16 is no more required internally\n  if (isNodeProcess()) {\n    return true;\n  }\n\n  const apiUrl = getApiUrl();\n\n  // Localhost generally doesn't work with HTTP 2 so we can stop here\n  if (apiUrl.startsWith('http://localhost')) {\n    return false;\n  }\n\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: 'POST',\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- could be false\n  return duplexAccessed && !hasContentType;\n})();\n\nexport function getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n\n  return `${baseUrl || defaultVercelBlobApiUrl}${pathname}`;\n}\n\nconst TEXT_ENCODER =\n  typeof TextEncoder === 'function' ? new TextEncoder() : null;\n\nexport function computeBodyLength(body: PutBody): number {\n  if (!body) {\n    return 0;\n  }\n\n  if (typeof body === 'string') {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n\n    // React Native doesn't have TextEncoder\n    return new Blob([body]).size;\n  }\n\n  if ('byteLength' in body && typeof body.byteLength === 'number') {\n    // handles Uint8Array, ArrayBuffer, Buffer, and ArrayBufferView\n    return body.byteLength;\n  }\n\n  if ('size' in body && typeof body.size === 'number') {\n    // handles Blob and File\n    return body.size;\n  }\n\n  return 0;\n}\n\nexport const createChunkTransformStream = (\n  chunkSize: number,\n  onProgress?: (bytes: number) => void,\n): TransformStream<ArrayBuffer | Uint8Array> => {\n  let buffer = new Uint8Array(0);\n\n  return new TransformStream<ArrayBuffer, Uint8Array>({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        // Combine the new chunk with any leftover data\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n\n        // Output complete chunks\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress?.(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n\n    flush(controller) {\n      queueMicrotask(() => {\n        // Send any remaining data\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress?.(buffer.byteLength);\n        }\n      });\n    },\n  });\n};\n\nexport function isReadableStream(value: PutBody): value is ReadableStream {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Not present in Node.js 16\n    globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream\n  );\n}\n\nexport function isStream(value: PutBody): value is ReadableStream | Readable {\n  if (isReadableStream(value)) {\n    return true;\n  }\n\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","/* eslint-disable -- This file is copy pasted*/\n// @ts-nocheck -- This file is copy pasted\n\n// Source: https://github.com/sindresorhus/is-network-error/blob/main/index.js\n// Why: Jest + ES6 modules = harder than maintaining a nuclear plant\n\n/**\n * MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst objectToString = Object.prototype.toString;\n\nconst isError = (value) => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n  'network error', // Chrome\n  'Failed to fetch', // Chrome\n  'NetworkError when attempting to fetch resource.', // Firefox\n  'The Internet connection appears to be offline.', // Safari 16\n  'Load failed', // Safari 17+\n  'Network request failed', // `cross-fetch`\n  'fetch failed', // Undici (Node.js)\n  'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n  const isValid =\n    error &&\n    isError(error) &&\n    error.name === 'TypeError' &&\n    typeof error.message === 'string';\n\n  if (!isValid) {\n    return false;\n  }\n\n  // We do an extra check for Safari 17+ as it has a very generic error message.\n  // Network errors in Safari have no stack.\n  if (error.message === 'Load failed') {\n    return error.stack === undefined;\n  }\n\n  return errorMessages.has(error.message);\n}\n","let debugIsActive = false;\n\n// wrapping this code in a try/catch in case some env doesn't support process.env (vite by default)\ntry {\n  if (\n    process.env.DEBUG?.includes('blob') ||\n    process.env.NEXT_PUBLIC_DEBUG?.includes('blob')\n  ) {\n    debugIsActive = true;\n  }\n} catch (error) {\n  // noop\n}\n\n// Set process.env.DEBUG = 'blob' to enable debug logging\nexport function debug(message: string, ...args: unknown[]): void {\n  if (debugIsActive) {\n    // eslint-disable-next-line no-console -- Ok for debugging\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n","import type { BodyInit } from 'undici';\nimport { fetch } from 'undici';\nimport type { BlobRequest } from './helpers';\nimport {\n  createChunkTransformStream,\n  isStream,\n  supportsRequestStreams,\n} from './helpers';\nimport { toReadableStream } from './multipart/helpers';\nimport type { PutBody } from './put-helpers';\nimport { debug } from './debug';\n\nexport const hasFetch = typeof fetch === 'function';\n\nexport const hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\n\nconst CHUNK_SIZE = 64 * 1024;\n\nexport const blobFetch: BlobRequest = async ({\n  input,\n  init,\n  onUploadProgress,\n}) => {\n  debug('using fetch');\n  let body: BodyInit | undefined;\n\n  if (init.body) {\n    if (onUploadProgress) {\n      // We transform the body to a stream here instead of at the call site\n      // So that on retries we can reuse the original body, otherwise we would not be able to reuse it\n      const stream = await toReadableStream(init.body);\n\n      let loaded = 0;\n\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded: number) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        },\n      );\n\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body as BodyInit;\n    }\n  }\n\n  // Only set duplex option when supported and dealing with a stream body\n  const duplex =\n    supportsRequestStreams && body && isStream(body as PutBody)\n      ? 'half'\n      : undefined;\n\n  return fetch(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...(init.body ? { body } : {}),\n      duplex,\n    },\n  );\n};\n","// TODO: Once Node 16 is no more needed internally, we can remove this file and use the native DOMException type.\n/* eslint-disable -- fine */\nexport const DOMException =\n  globalThis.DOMException ??\n  (() => {\n    // DOMException was only made a global in Node v17.0.0,\n    // but fetch supports >= v16.8.\n    try {\n      atob('~');\n    } catch (err) {\n      return Object.getPrototypeOf(err).constructor;\n    }\n  })();\n","import type { Response as UndiciResponse } from 'undici';\nimport { isReadableStream, type BlobRequest } from './helpers';\nimport { debug } from './debug';\n\nexport const hasXhr = typeof XMLHttpRequest !== 'undefined';\n\nexport const blobXhr: BlobRequest = async ({\n  input,\n  init,\n  onUploadProgress,\n}) => {\n  debug('using xhr');\n  let body: XMLHttpRequestBodyInit | null = null;\n\n  // xhr.send only support XMLHttpRequestBodyInit types, excluding ReadableStream (web)\n  // and Readable (node)\n  // We do have to support ReadableStream being sent to xhr as our library allows\n  // for Safari to use put(path, ReadableStream, { onUploadProgress }) which would\n  // end up here.\n  // We do not have to support Readable being sent to xhr as using Node.js you would\n  // endup in the fetch implementation by default.\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      // We \"type lie\" here, what we should do instead:\n      // Exclude ReadableStream:\n      // body = init.body as Exclude<PutBody, ReadableStream | Readable>;\n      // We can't do this because init.body (PutBody) relies on Blob (node:buffer)\n      // while XMLHttpRequestBodyInit relies on native Blob type.\n      // If we get rid of undici we can remove this trick.\n      body = init.body as XMLHttpRequestBodyInit;\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || 'GET', input.toString(), true);\n\n    // Handle upload progress\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n\n    // Handle response\n    xhr.onload = () => {\n      if (init.signal?.aborted) {\n        reject(new DOMException('The user aborted the request.', 'AbortError'));\n        return;\n      }\n\n      const headers = new Headers();\n      const rawHeaders = xhr\n        .getAllResponseHeaders()\n        .trim()\n        .split(/[\\r\\n]+/);\n\n      // Parse headers\n      rawHeaders.forEach((line) => {\n        const parts = line.split(': ');\n        const key = parts.shift();\n        const value = parts.join(': ');\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n\n      // Create response object, api-blob sends back text and api.ts will turn it into json if necessary\n      const response = new Response(xhr.response as string, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers,\n      }) as unknown as UndiciResponse;\n\n      resolve(response);\n    };\n\n    // Handle network errors\n    xhr.onerror = () => {\n      reject(new TypeError('Network request failed'));\n    };\n\n    // Handle timeouts\n    xhr.ontimeout = () => {\n      reject(new TypeError('Network request timed out'));\n    };\n\n    // Handle aborts\n    xhr.onabort = () => {\n      reject(new DOMException('The user aborted a request.', 'AbortError'));\n    };\n\n    // Set headers\n    if (init.headers) {\n      const headers = new Headers(init.headers as HeadersInit);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n\n    // Handle abort signal\n    if (init.signal) {\n      init.signal.addEventListener('abort', () => {\n        xhr.abort();\n      });\n\n      // If already aborted, abort xhr immediately\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n\n    // We're cheating and saying that nobody is gonna use put() with a stream in an environment not supporting\n    // fetch with streams. If this ever happens please open an issue and we'll figure it out.\n    xhr.send(body);\n  });\n};\n","import type { Response } from 'undici';\nimport retry from 'async-retry';\nimport isNetworkError from './is-network-error';\nimport { debug } from './debug';\nimport type {\n  BlobCommandOptions,\n  BlobRequestInit,\n  WithUploadProgress,\n} from './helpers';\nimport {\n  BlobError,\n  computeBodyLength,\n  getApiUrl,\n  getTokenFromOptionsOrEnv,\n} from './helpers';\nimport { blobRequest } from './request';\nimport { DOMException } from './dom-exception';\n\n// maximum pathname length is:\n// 1024 (provider limit) - 26 chars (vercel  internal suffixes) - 31 chars (blob `-randomId` suffix) = 967\n// we round it to 950 to make it more human friendly, and we apply the limit whatever the value of\n// addRandomSuffix is, to make it consistent\nexport const MAXIMUM_PATHNAME_LENGTH = 950;\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource.');\n  }\n}\n\nexport class BlobContentTypeNotAllowedError extends BlobError {\n  constructor(message: string) {\n    super(`Content type mismatch, ${message}.`);\n  }\n}\n\nexport class BlobPathnameMismatchError extends BlobError {\n  constructor(message: string) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`,\n    );\n  }\n}\n\nexport class BlobClientTokenExpiredError extends BlobError {\n  constructor() {\n    super('Client token has expired.');\n  }\n}\n\nexport class BlobFileTooLargeError extends BlobError {\n  constructor(message: string) {\n    super(`File is too large, ${message}.`);\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist.');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended.');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help.');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\nexport class BlobServiceNotAvailable extends BlobError {\n  constructor() {\n    super('The blob service is currently not available. Please try again.');\n  }\n}\n\nexport class BlobServiceRateLimited extends BlobError {\n  public readonly retryAfter: number;\n\n  constructor(seconds?: number) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${\n        seconds ? ` - try again in ${seconds} seconds` : ''\n      }.`,\n    );\n\n    this.retryAfter = seconds ?? 0;\n  }\n}\n\nexport class BlobRequestAbortedError extends BlobError {\n  constructor() {\n    super('The request was aborted.');\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed'\n  | 'service_unavailable'\n  | 'rate_limited'\n  | 'content_type_not_allowed'\n  | 'client_token_pathname_mismatch'\n  | 'client_token_expired'\n  | 'file_too_large';\n\nexport interface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 11;\n\nfunction getApiVersion(): string {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return `${versionOverride ?? BLOB_API_VERSION}`;\n}\n\nfunction getRetries(): number {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || '10';\n\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\n\nfunction createBlobServiceRateLimited(\n  response: Response,\n): BlobServiceRateLimited {\n  const retryAfter = response.headers.get('retry-after');\n\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : undefined,\n  );\n}\n\n// reads the body of a error response\nasync function getBlobError(\n  response: Response,\n): Promise<{ code: string; error: BlobError }> {\n  let code: BlobApiErrorCodes;\n  let message: string | undefined;\n\n  try {\n    const data = (await response.json()) as BlobApiError;\n    code = data.error?.code ?? 'unknown_error';\n    message = data.error?.message;\n  } catch {\n    code = 'unknown_error';\n  }\n\n  // Now that we have multiple API clients out in the wild handling errors, we can't just send a different\n  // error code for this type of error. We need to add a new field in the API response to handle this correctly,\n  // but for now, we can just check the message.\n  if (message?.includes('contentType') && message.includes('is not allowed')) {\n    code = 'content_type_not_allowed';\n  }\n\n  if (\n    message?.includes('\"pathname\"') &&\n    message.includes('does not match the token payload')\n  ) {\n    code = 'client_token_pathname_mismatch';\n  }\n\n  if (message === 'Token expired') {\n    code = 'client_token_expired';\n  }\n\n  if (message?.includes('the file length cannot be greater than')) {\n    code = 'file_too_large';\n  }\n\n  let error: BlobError;\n  switch (code) {\n    case 'store_suspended':\n      error = new BlobStoreSuspendedError();\n      break;\n    case 'forbidden':\n      error = new BlobAccessError();\n      break;\n    case 'content_type_not_allowed':\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TS, be smarter\n      error = new BlobContentTypeNotAllowedError(message!);\n      break;\n    case 'client_token_pathname_mismatch':\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TS, be smarter\n      error = new BlobPathnameMismatchError(message!);\n      break;\n    case 'client_token_expired':\n      error = new BlobClientTokenExpiredError();\n      break;\n    case 'file_too_large':\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TS, be smarter\n      error = new BlobFileTooLargeError(message!);\n      break;\n    case 'not_found':\n      error = new BlobNotFoundError();\n      break;\n    case 'store_not_found':\n      error = new BlobStoreNotFoundError();\n      break;\n    case 'bad_request':\n      error = new BlobError(message ?? 'Bad request');\n      break;\n    case 'service_unavailable':\n      error = new BlobServiceNotAvailable();\n      break;\n    case 'rate_limited':\n      error = createBlobServiceRateLimited(response);\n      break;\n    case 'unknown_error':\n    case 'not_allowed':\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n\n  return { code, error };\n}\n\nexport async function requestApi<TResponse>(\n  pathname: string,\n  init: BlobRequestInit,\n  commandOptions: (BlobCommandOptions & WithUploadProgress) | undefined,\n): Promise<TResponse> {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n\n  const [, , , storeId = ''] = token.split('_');\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength =\n    commandOptions?.onUploadProgress || shouldUseXContentLength();\n\n  if (\n    init.body &&\n    // 1. For upload progress we always need to know the total size of the body\n    // 2. In development we need the header for put() to work correctly when passing a stream\n    sendBodyLength\n  ) {\n    bodyLength = computeBodyLength(init.body);\n  }\n\n  if (commandOptions?.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0,\n    });\n  }\n\n  const apiResponse = await retry(\n    async (bail) => {\n      let res: Response;\n\n      // try/catch here to treat certain errors as not-retryable\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              'x-api-blob-request-id': requestId,\n              'x-api-blob-request-attempt': String(retryCount),\n              'x-api-version': apiVersion,\n              ...(sendBodyLength\n                ? { 'x-content-length': String(bodyLength) }\n                : {}),\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers,\n            },\n          },\n          onUploadProgress: commandOptions?.onUploadProgress\n            ? (loaded) => {\n                const total = bodyLength !== 0 ? bodyLength : loaded;\n                totalLoaded = loaded;\n                const percentage =\n                  bodyLength > 0\n                    ? Number(((loaded / total) * 100).toFixed(2))\n                    : 0;\n\n                // Leave percentage 100 for the end of request\n                if (percentage === 100 && bodyLength > 0) {\n                  return;\n                }\n\n                commandOptions.onUploadProgress?.({\n                  loaded,\n                  // When passing a stream to put(), we have no way to know the total size of the body.\n                  // Instead of defining total as total?: number we decided to set the total to the currently\n                  // loaded number. This is not inaccurate and way more practical for DX.\n                  // Passing down a stream to put() is very rare\n                  total,\n                  percentage,\n                });\n              }\n            : undefined,\n        });\n      } catch (error) {\n        // if the request was aborted, don't retry\n        if (error instanceof DOMException && error.name === 'AbortError') {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n\n        // We specifically target network errors because fetch network errors are regular TypeErrors\n        // We want to retry for network errors, but not for other TypeErrors\n        if (isNetworkError(error)) {\n          throw error;\n        }\n\n        // If we messed up the request part, don't even retry\n        if (error instanceof TypeError) {\n          bail(error);\n          return;\n        }\n\n        // retry for any other erros thrown by fetch\n        throw error;\n      }\n\n      if (res.ok) {\n        return res;\n      }\n\n      const { code, error } = await getBlobError(res);\n\n      // only retry for certain errors\n      if (\n        code === 'unknown_error' ||\n        code === 'service_unavailable' ||\n        code === 'internal_server_error'\n      ) {\n        throw error;\n      }\n\n      // don't retry for e.g. suspended stores\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n\n        retryCount = retryCount + 1;\n      },\n    },\n  );\n\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n\n  // Calling onUploadProgress here has two benefits:\n  // 1. It ensures 100% is only reached at the end of the request. While otherwise you can reach 100%\n  // before the request is fully done, as we only really measure what gets sent over the wire, not what\n  // has been processed by the server.\n  // 2. It makes the uploadProgress \"work\" even in rare cases where fetch/xhr onprogress is not working\n  // And in the case of multipart uploads it actually provides a simple progress indication (per part)\n  if (commandOptions?.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100,\n    });\n  }\n\n  return (await apiResponse.json()) as TResponse;\n}\n\nfunction getProxyThroughAlternativeApiHeaderFromEnv(): {\n  'x-proxy-through-alternative-api'?: string;\n} {\n  const extraHeaders: Record<string, string> = {};\n\n  try {\n    if (\n      'VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API' in process.env &&\n      process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== undefined\n    ) {\n      extraHeaders['x-proxy-through-alternative-api'] =\n        process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\n      'NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API' in process.env &&\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !==\n        undefined\n    ) {\n      extraHeaders['x-proxy-through-alternative-api'] =\n        process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n    // noop\n  }\n\n  return extraHeaders;\n}\n\nfunction shouldUseXContentLength(): boolean {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === '1';\n  } catch {\n    return false;\n  }\n}\n","import type { Response } from 'undici';\nimport { blobFetch, hasFetch, hasFetchWithUploadProgress } from './fetch';\nimport { hasXhr, blobXhr } from './xhr';\nimport type { BlobRequest } from './helpers';\n\nexport const blobRequest: BlobRequest = async ({\n  input,\n  init,\n  onUploadProgress,\n}): Promise<Response> => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n\n  throw new Error('No request implementation available');\n};\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport type { Readable } from 'stream';\n// We use the undici types to ensure TS doesn't complain about native types (like ReadableStream) vs\n// undici types fetch expects (like Blob is from node:buffer..)\n// import type { Blob } from 'node:buffer';\nimport type { File } from 'undici';\nimport type { ClientCommonCreateBlobOptions } from './client';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError, disallowedPathnameCharacters } from './helpers';\nimport { MAXIMUM_PATHNAME_LENGTH } from './api';\n\nexport const putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  allowOverwrite: 'x-allow-overwrite',\n  contentType: 'x-content-type',\n};\n\n/**\n * Result of a successful put or copy operation.\n */\nexport interface PutBlobResult {\n  /**\n   * The URL of the blob.\n   */\n  url: string;\n  /**\n   * A URL that will cause browsers to download the file instead of displaying it inline.\n   */\n  downloadUrl: string;\n  /**\n   * The pathname of the blob within the store.\n   */\n  pathname: string;\n  /**\n   * The content-type of the blob.\n   */\n  contentType: string;\n  /**\n   * The content disposition header value.\n   */\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\n/**\n * Represents the body content for a put operation.\n * Can be one of several supported types.\n */\nexport type PutBody =\n  | string\n  | Readable // Node.js streams\n  | Buffer // Node.js buffers\n  | Blob\n  | ArrayBuffer\n  | ReadableStream // Streams API (= Web streams in Node.js)\n  | File;\n\nexport type CommonPutCommandOptions = CommonCreateBlobOptions &\n  ClientCommonCreateBlobOptions;\n\nexport interface CreatePutMethodOptions<TOptions> {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: TOptions) => Promise<string>;\n  extraChecks?: (options: TOptions) => void;\n}\n\nexport function createPutHeaders<TOptions extends CommonPutCommandOptions>(\n  allowedOptions: CreatePutMethodOptions<TOptions>['allowedOptions'],\n  options: TOptions,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n\n  if (allowedOptions.includes('contentType') && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n\n  if (\n    allowedOptions.includes('addRandomSuffix') &&\n    options.addRandomSuffix !== undefined\n  ) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix\n      ? '1'\n      : '0';\n  }\n\n  if (\n    allowedOptions.includes('allowOverwrite') &&\n    options.allowOverwrite !== undefined\n  ) {\n    headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite\n      ? '1'\n      : '0';\n  }\n\n  if (\n    allowedOptions.includes('cacheControlMaxAge') &&\n    options.cacheControlMaxAge !== undefined\n  ) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] =\n      options.cacheControlMaxAge.toString();\n  }\n\n  return headers;\n}\n\nexport async function createPutOptions<\n  TOptions extends CommonPutCommandOptions,\n>({\n  pathname,\n  options,\n  extraChecks,\n  getToken,\n}: {\n  pathname: string;\n  options?: TOptions;\n  extraChecks?: CreatePutMethodOptions<TOptions>['extraChecks'];\n  getToken?: CreatePutMethodOptions<TOptions>['getToken'];\n}): Promise<TOptions> {\n  if (!pathname) {\n    throw new BlobError('pathname is required');\n  }\n\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`,\n    );\n  }\n\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`,\n      );\n    }\n  }\n\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  if (extraChecks) {\n    extraChecks(options);\n  }\n\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n\n  return options;\n}\n","import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { CommonCreateBlobOptions, BlobCommandOptions } from '../helpers';\nimport type {\n  CreatePutMethodOptions,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { Part } from './helpers';\n\n/**\n * Options for completing a multipart upload.\n * Used with the completeMultipartUpload method.\n */\nexport interface CommonCompleteMultipartUploadOptions {\n  /**\n   * Unique upload identifier for the multipart upload, received from createMultipartUpload.\n   * This ID is used to identify which multipart upload is being completed.\n   */\n  uploadId: string;\n\n  /**\n   * Unique key identifying the blob object, received from createMultipartUpload.\n   * This key is used to identify which blob object the parts belong to.\n   */\n  key: string;\n}\n\nexport type CompleteMultipartUploadCommandOptions =\n  CommonCompleteMultipartUploadOptions & CommonCreateBlobOptions;\n\nexport function createCompleteMultipartUploadMethod<\n  TOptions extends CompleteMultipartUploadCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, parts: Part[], optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts,\n    });\n  };\n}\n\nexport async function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  parts: Part[];\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n}): Promise<PutBlobResult> {\n  const params = new URLSearchParams({ pathname });\n\n  try {\n    const response = await requestApi<PutBlobApiResponse>(\n      `/mpu?${params.toString()}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'content-type': 'application/json',\n          'x-mpu-action': 'complete',\n          'x-mpu-upload-id': uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          'x-mpu-key': encodeURIComponent(key),\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal,\n      },\n      options,\n    );\n\n    debug('mpu: complete', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n","import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { BlobCommandOptions, CommonCreateBlobOptions } from '../helpers';\nimport type { CreatePutMethodOptions } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\n\nexport function createCreateMultipartUploadMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n    };\n  };\n}\n\ninterface CreateMultipartUploadApiResponse {\n  uploadId: string;\n  key: string;\n}\n\nexport async function createMultipartUpload(\n  pathname: string,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<CreateMultipartUploadApiResponse> {\n  debug('mpu: create', 'pathname:', pathname);\n\n  const params = new URLSearchParams({ pathname });\n\n  try {\n    const response = await requestApi<CreateMultipartUploadApiResponse>(\n      `/mpu?${params.toString()}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'x-mpu-action': 'create',\n        },\n        signal: options.abortSignal,\n      },\n      options,\n    );\n\n    debug('mpu: create', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    }\n\n    throw error;\n  }\n}\n","import throttle from 'throttleit';\nimport { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport { BlobError, isPlainObject, bytes } from '../helpers';\nimport type {\n  WithUploadProgress,\n  CommonCreateBlobOptions,\n  BlobCommandOptions,\n} from '../helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { PutBody, CreatePutMethodOptions } from '../put-helpers';\nimport type { Part, PartInput } from './helpers';\n\n/**\n * Options for uploading a part in a multipart upload process.\n * Used with the uploadPart method.\n */\nexport interface CommonMultipartUploadOptions {\n  /**\n   * Unique upload identifier for the multipart upload, received from createMultipartUpload.\n   * This ID is used to associate all uploaded parts with the same multipart upload.\n   */\n  uploadId: string;\n\n  /**\n   * Unique key identifying the blob object, received from createMultipartUpload.\n   * This key is used to identify which blob object the parts belong to.\n   */\n  key: string;\n\n  /**\n   * A number identifying which part is being uploaded (1-based).\n   * This number is used to order the parts when completing the multipart upload.\n   * Parts must be uploaded with consecutive part numbers starting from 1.\n   */\n  partNumber: number;\n}\n\nexport type UploadPartCommandOptions = CommonMultipartUploadOptions &\n  CommonCreateBlobOptions;\n\nexport function createUploadPartMethod<\n  TOptions extends UploadPartCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (\n    pathname: string,\n    body: PutBody,\n    optionsInput: TOptions,\n  ): Promise<Part> => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n      );\n    }\n\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options,\n    });\n\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber,\n    };\n  };\n}\n\nexport async function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  headers: Record<string, string>;\n  options: BlobCommandOptions & WithUploadProgress;\n  internalAbortController?: AbortController;\n  part: PartInput;\n}): Promise<UploadPartApiResponse> {\n  const params = new URLSearchParams({ pathname });\n\n  const responsePromise = requestApi<UploadPartApiResponse>(\n    `/mpu?${params.toString()}`,\n    {\n      signal: internalAbortController.signal,\n      method: 'POST',\n      headers: {\n        ...headers,\n        'x-mpu-action': 'upload',\n        'x-mpu-key': encodeURIComponent(key),\n        'x-mpu-upload-id': uploadId,\n        'x-mpu-part-number': part.partNumber.toString(),\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob,\n    },\n    options,\n  );\n\n  function handleAbort(): void {\n    internalAbortController.abort();\n  }\n\n  if (options.abortSignal?.aborted) {\n    // abort if the signal is already aborted\n    handleAbort();\n  } else {\n    // we connect the internal abort controller to the external abortSignal to allow the user to cancel the upload\n    options.abortSignal?.addEventListener('abort', handleAbort);\n  }\n\n  const response = await responsePromise;\n\n  options.abortSignal?.removeEventListener('abort', handleAbort);\n\n  return response;\n}\n\n// Most browsers will cap requests at 6 concurrent uploads per domain (Vercel Blob API domain)\n// In other environments, we can afford to be more aggressive\nconst maxConcurrentUploads = typeof window !== 'undefined' ? 6 : 8;\n\n// 5MB is the minimum part size accepted by Vercel Blob, but we set our default part size to 8mb like the aws cli\nconst partSizeInBytes = 8 * 1024 * 1024;\n\nconst maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\n\ninterface UploadPartApiResponse {\n  etag: string;\n}\n\nexport interface BlobUploadPart {\n  partNumber: number;\n  blob: Blob;\n}\n\n// Can we rewrite this function without new Promise?\nexport function uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  stream: ReadableStream<ArrayBuffer>;\n  headers: Record<string, string>;\n  options: BlobCommandOptions & WithUploadProgress;\n  totalToLoad: number;\n}): Promise<Part[]> {\n  debug('mpu: upload init', 'key:', key);\n  const internalAbortController = new AbortController();\n\n  return new Promise((resolve, reject) => {\n    const partsToUpload: BlobUploadPart[] = [];\n    const completedParts: Part[] = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    // this next variable is used to escape the read loop when an error occurs\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n\n    // This must be outside the read loop, in case we reach the maxBytesInMemory and\n    // we exit the loop but some bytes are still to be sent on the next read invocation.\n    let arrayBuffers: ArrayBuffer[] = [];\n    let currentPartBytesRead = 0;\n\n    let onUploadProgress: (() => void) | undefined;\n    const totalLoadedPerPartNumber: Record<string, number> = {};\n\n    if (options.onUploadProgress) {\n      onUploadProgress = throttle(() => {\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0,\n        );\n        const total = totalToLoad || loaded;\n        const percentage =\n          totalToLoad > 0\n            ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2))\n            : 0;\n\n        // we call the user's onUploadProgress callback\n        options.onUploadProgress?.({ loaded, total, percentage });\n      }, 150);\n    }\n\n    read().catch(cancel);\n\n    async function read(): Promise<void> {\n      debug(\n        'mpu: upload read start',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = true;\n\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          // eslint-disable-next-line no-await-in-loop -- A for loop is fine here.\n          const { value, done } = await reader.read();\n\n          if (done) {\n            doneReading = true;\n            debug('mpu: upload read consumed the whole stream');\n            // done is sent when the stream is fully consumed. That's why we're not using the value here.\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n\n          currentBytesInMemory += value.byteLength;\n\n          // This code ensures that each part will be exactly of `partSizeInBytes` size\n          // Otherwise R2 will refuse it. AWS S3 is fine with parts of different sizes.\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength,\n            );\n\n            const chunk = value.slice(valueOffset, endOffset);\n\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n\n      debug(\n        'mpu: upload read end',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = false;\n    }\n\n    async function sendPart(part: BlobUploadPart): Promise<void> {\n      activeUploads++;\n\n      debug(\n        'mpu: upload send part start',\n        'partNumber:',\n        part.partNumber,\n        'size:',\n        part.blob.size,\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      try {\n        const uploadProgressForPart: WithUploadProgress['onUploadProgress'] =\n          options.onUploadProgress\n            ? (event) => {\n                totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n                if (onUploadProgress) {\n                  onUploadProgress();\n                }\n              }\n            : undefined;\n\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart,\n          },\n          internalAbortController,\n          part,\n        });\n\n        debug(\n          'mpu: upload send part end',\n          'partNumber:',\n          part.partNumber,\n          'activeUploads',\n          activeUploads,\n          'currentBytesInMemory:',\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          'bytesSent:',\n          bytes(bytesSent),\n        );\n\n        if (rejected) {\n          return;\n        }\n\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag,\n        });\n\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        // cancel if fetch throws an error\n        cancel(error);\n      }\n    }\n\n    function sendParts(): void {\n      if (rejected) {\n        return;\n      }\n\n      debug(\n        'send parts',\n        'activeUploads',\n        activeUploads,\n        'partsToUpload',\n        partsToUpload.length,\n      );\n\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n\n    function cancel(error: unknown): void {\n      // a previous call already rejected the whole call, ignore\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (\n        error instanceof TypeError &&\n        (error.message === 'Failed to fetch' ||\n          error.message === 'fetch failed')\n      ) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error as Error);\n      }\n    }\n  });\n}\n","import { debug } from '../debug';\nimport { computeBodyLength } from '../helpers';\nimport type { WithUploadProgress, BlobCommandOptions } from '../helpers';\nimport type { PutBody, PutBlobResult } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport { toReadableStream } from './helpers';\nimport { uploadAllParts } from './upload';\n\n// this automatically slices the body into parts and uploads all of them as multiple parts\nexport async function uncontrolledMultipartUpload(\n  pathname: string,\n  body: PutBody,\n  headers: Record<string, string>,\n  options: BlobCommandOptions & WithUploadProgress,\n): Promise<PutBlobResult> {\n  debug('mpu: init', 'pathname:', pathname, 'headers:', headers);\n\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: undefined,\n  };\n\n  // Step 1: Start multipart upload\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress,\n  );\n\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n\n  // Step 2: Upload parts one by one\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad,\n  });\n\n  // Step 3: Complete multipart upload\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress,\n  });\n\n  // changes:\n  // stream => set percentage to 0% even if loaded/total is valid\n  // stream => send onUploadProgress 100% at the end of the request here\n\n  return blob;\n}\n","import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\nimport { createCreateMultipartUploadMethod } from './multipart/create';\nimport type { UploadPartCommandOptions } from './multipart/upload';\nimport { createUploadPartMethod } from './multipart/upload';\nimport type { CompleteMultipartUploadCommandOptions } from './multipart/complete';\nimport { createCompleteMultipartUploadMethod } from './multipart/complete';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { createCreateMultipartUploaderMethod } from './multipart/create-uploader';\n\n// expose generic BlobError and download url util\nexport {\n  BlobError,\n  getDownloadUrl,\n  type OnUploadProgressCallback,\n  type UploadProgressEvent,\n} from './helpers';\n\n// expose api BlobErrors\nexport {\n  BlobAccessError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  BlobServiceNotAvailable,\n  BlobRequestAbortedError,\n  BlobServiceRateLimited,\n  BlobContentTypeNotAllowedError,\n  BlobPathnameMismatchError,\n  BlobClientTokenExpiredError,\n  BlobFileTooLargeError,\n} from './api';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult } from './put-helpers';\nexport type { PutCommandOptions };\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, or if you're hitting Vercel upload limits, check out the documentation for client uploads: https://vercel.com/docs/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to, including the extension. This will influence the URL of your blob like https://$storeId.public.blob.vercel-storage.com/$pathname.\n * @param body - The content of your blob, can be a: string, File, Blob, Buffer or Stream. We support almost everything fetch supports: https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#body.\n * @param options - Configuration options including:\n *   - access - (Required) Must be 'public' as blobs are publicly accessible.\n *   - addRandomSuffix - (Optional) A boolean specifying whether to add a random suffix to the pathname. It defaults to false. We recommend using this option to ensure there are no conflicts in your blob filenames.\n *   - allowOverwrite - (Optional) A boolean to allow overwriting blobs. By default an error will be thrown if you try to overwrite a blob by using the same pathname for multiple blobs.\n *   - contentType - (Optional) A string indicating the media type. By default, it's extracted from the pathname's extension.\n *   - cacheControlMaxAge - (Optional) A number in seconds to configure how long Blobs are cached. Defaults to one month. Cannot be set to a value lower than 1 minute.\n *   - token - (Optional) A string specifying the token to use when making requests. It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.\n *   - multipart - (Optional) Whether to use multipart upload for large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.\n *   - abortSignal - (Optional) AbortSignal to cancel the operation.\n *   - onUploadProgress - (Optional) Callback to track upload progress: onUploadProgress(\\{loaded: number, total: number, percentage: number\\})\n * @returns A promise that resolves to the blob information, including pathname, contentType, contentDisposition, url, and downloadUrl.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: [\n    'cacheControlMaxAge',\n    'addRandomSuffix',\n    'allowOverwrite',\n    'contentType',\n  ],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n\n// vercelBlob. createMultipartUpload()\n// vercelBlob. uploadPart()\n// vercelBlob. completeMultipartUpload()\n// vercelBlob. createMultipartUploader()\n\n/**\n * Creates a multipart upload. This is the first step in the manual multipart upload process.\n *\n * @param pathname - A string specifying the path inside the blob store. This will be the base value of the return URL and includes the filename and extension.\n * @param options - Configuration options including:\n *   - access - (Required) Must be 'public' as blobs are publicly accessible.\n *   - addRandomSuffix - (Optional) A boolean specifying whether to add a random suffix to the pathname. It defaults to true.\n *   - allowOverwrite - (Optional) A boolean to allow overwriting blobs. By default an error will be thrown if you try to overwrite a blob by using the same pathname for multiple blobs.\n *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension. Falls back to application/octet-stream when no extension exists or can't be matched.\n *   - cacheControlMaxAge - (Optional) A number in seconds to configure the edge and browser cache. Defaults to one year.\n *   - token - (Optional) A string specifying the token to use when making requests. It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.\n *   - abortSignal - (Optional) AbortSignal to cancel the operation.\n * @returns A promise that resolves to an object containing:\n *   - key: A string that identifies the blob object.\n *   - uploadId: A string that identifies the multipart upload. Both are needed for subsequent uploadPart calls.\n */\nexport const createMultipartUpload =\n  createCreateMultipartUploadMethod<CommonCreateBlobOptions>({\n    allowedOptions: [\n      'cacheControlMaxAge',\n      'addRandomSuffix',\n      'allowOverwrite',\n      'contentType',\n    ],\n  });\n\n/**\n * Creates a multipart uploader that simplifies the multipart upload process.\n * This is a wrapper around the manual multipart upload process that provides a more convenient API.\n *\n * @param pathname - A string specifying the path inside the blob store. This will be the base value of the return URL and includes the filename and extension.\n * @param options - Configuration options including:\n *   - access - (Required) Must be 'public' as blobs are publicly accessible.\n *   - addRandomSuffix - (Optional) A boolean specifying whether to add a random suffix to the pathname. It defaults to true.\n *   - allowOverwrite - (Optional) A boolean to allow overwriting blobs. By default an error will be thrown if you try to overwrite a blob by using the same pathname for multiple blobs.\n *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension. Falls back to application/octet-stream when no extension exists or can't be matched.\n *   - cacheControlMaxAge - (Optional) A number in seconds to configure the edge and browser cache. Defaults to one year.\n *   - token - (Optional) A string specifying the token to use when making requests. It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.\n *   - abortSignal - (Optional) AbortSignal to cancel the operation.\n * @returns A promise that resolves to an uploader object with the following properties and methods:\n *   - key: A string that identifies the blob object.\n *   - uploadId: A string that identifies the multipart upload.\n *   - uploadPart: A method to upload a part of the file.\n *   - complete: A method to complete the multipart upload process.\n */\nexport const createMultipartUploader =\n  createCreateMultipartUploaderMethod<CommonCreateBlobOptions>({\n    allowedOptions: [\n      'cacheControlMaxAge',\n      'addRandomSuffix',\n      'allowOverwrite',\n      'contentType',\n    ],\n  });\n\nexport type { UploadPartCommandOptions };\n\n/**\n * Uploads a part of a multipart upload.\n * Used as part of the manual multipart upload process.\n *\n * @param pathname - Same value as the pathname parameter passed to createMultipartUpload. This will influence the final URL of your blob.\n * @param body - A blob object as ReadableStream, String, ArrayBuffer or Blob based on these supported body types. Each part must be a minimum of 5MB, except the last one which can be smaller.\n * @param options - Configuration options including:\n *   - access - (Required) Must be 'public' as blobs are publicly accessible.\n *   - uploadId - (Required) A string returned from createMultipartUpload which identifies the multipart upload.\n *   - key - (Required) A string returned from createMultipartUpload which identifies the blob object.\n *   - partNumber - (Required) A number identifying which part is uploaded (1-based index).\n *   - contentType - (Optional) The media type for the blob. By default, it's derived from the pathname.\n *   - token - (Optional) A string specifying the token to use when making requests. It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.\n *   - addRandomSuffix - (Optional) A boolean specifying whether to add a random suffix to the pathname.\n *   - allowOverwrite - (Optional) A boolean to allow overwriting blobs.\n *   - cacheControlMaxAge - (Optional) A number in seconds to configure how long Blobs are cached.\n *   - abortSignal - (Optional) AbortSignal to cancel the running request.\n *   - onUploadProgress - (Optional) Callback to track upload progress: onUploadProgress(\\{loaded: number, total: number, percentage: number\\})\n * @returns A promise that resolves to the uploaded part information containing etag and partNumber, which will be needed for the completeMultipartUpload call.\n */\nexport const uploadPart = createUploadPartMethod<UploadPartCommandOptions>({\n  allowedOptions: [\n    'cacheControlMaxAge',\n    'addRandomSuffix',\n    'allowOverwrite',\n    'contentType',\n  ],\n});\n\nexport type { CompleteMultipartUploadCommandOptions };\n\n/**\n * Completes a multipart upload by combining all uploaded parts.\n * This is the final step in the manual multipart upload process.\n *\n * @param pathname - Same value as the pathname parameter passed to createMultipartUpload.\n * @param parts - An array containing all the uploaded parts information from previous uploadPart calls. Each part must have properties etag and partNumber.\n * @param options - Configuration options including:\n *   - access - (Required) Must be 'public' as blobs are publicly accessible.\n *   - uploadId - (Required) A string returned from createMultipartUpload which identifies the multipart upload.\n *   - key - (Required) A string returned from createMultipartUpload which identifies the blob object.\n *   - contentType - (Optional) The media type for the file. If not specified, it's derived from the file extension.\n *   - token - (Optional) A string specifying the token to use when making requests. It defaults to process.env.BLOB_READ_WRITE_TOKEN when deployed on Vercel.\n *   - addRandomSuffix - (Optional) A boolean specifying whether to add a random suffix to the pathname. It defaults to true.\n *   - allowOverwrite - (Optional) A boolean to allow overwriting blobs.\n *   - cacheControlMaxAge - (Optional) A number in seconds to configure the edge and browser cache. Defaults to one year.\n *   - abortSignal - (Optional) AbortSignal to cancel the operation.\n * @returns A promise that resolves to the finalized blob information, including pathname, contentType, contentDisposition, url, and downloadUrl.\n */\nexport const completeMultipartUpload =\n  createCompleteMultipartUploadMethod<CompleteMultipartUploadCommandOptions>({\n    allowedOptions: [\n      'cacheControlMaxAge',\n      'addRandomSuffix',\n      'allowOverwrite',\n      'contentType',\n    ],\n  });\n\nexport type { Part, PartInput } from './multipart/helpers';\n\nexport { createFolder } from './create-folder';\n","import throttle from 'throttleit';\nimport { requestApi } from './api';\nimport type { CommonCreateBlobOptions, WithUploadProgress } from './helpers';\nimport { BlobError, isPlainObject } from './helpers';\nimport { uncontrolledMultipartUpload } from './multipart/uncontrolled';\nimport type {\n  CreatePutMethodOptions,\n  PutBody,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from './put-helpers';\nimport { createPutOptions, createPutHeaders } from './put-helpers';\n\nexport interface PutCommandOptions\n  extends CommonCreateBlobOptions,\n    WithUploadProgress {\n  /**\n   * Whether to use multipart upload. Use this when uploading large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.\n   * @defaultvalue false\n   */\n  multipart?: boolean;\n}\n\nexport function createPutMethod<TOptions extends PutCommandOptions>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: CreatePutMethodOptions<TOptions>) {\n  return async function put(\n    pathname: string,\n    body: PutBody,\n    optionsInput: TOptions,\n  ): Promise<PutBlobResult> {\n    if (!body) {\n      throw new BlobError('body is required');\n    }\n\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n      );\n    }\n\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n\n    const onUploadProgress = options.onUploadProgress\n      ? throttle(options.onUploadProgress, 100)\n      : undefined;\n\n    const params = new URLSearchParams({ pathname });\n\n    const response = await requestApi<PutBlobApiResponse>(\n      `/?${params.toString()}`,\n      {\n        method: 'PUT',\n        body,\n        headers,\n        signal: options.abortSignal,\n      },\n      {\n        ...options,\n        onUploadProgress,\n      },\n    );\n\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition,\n    };\n  };\n}\n","import {\n  BlobError,\n  isPlainObject,\n  type CommonCreateBlobOptions,\n} from '../helpers';\nimport type { CreatePutMethodOptions, PutBody } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport type { Part } from './helpers';\nimport { uploadPart as rawUploadPart } from './upload';\n\nexport function createCreateMultipartUploaderMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n\n      async uploadPart(partNumber: number, body: PutBody) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n          );\n        }\n\n        const result = await rawUploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options,\n        });\n\n        return {\n          etag: result.etag,\n          partNumber,\n        };\n      },\n\n      async complete(parts: Part[]) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options,\n        });\n      },\n    };\n  };\n}\n"],"names":["module","exports","retrier","require","fn","opts","Promise","resolve","reject","op","options","bail","err","Error","onError","num","retry","onRetry","mainError","randomize","operation","attempt","val","then","catch","function_","wait","TypeError","concat","timeoutId","lastCallTime","_len","arguments","length","arguments_","Array","_key","clearTimeout","now","Date","delayForNextCall","apply","this","setTimeout","RetryOperation","timeouts","forever","retries","Infinity","unref","maxRetryTime","factor","minTimeout","maxTimeout","key","i","push","createTimeout","sort","a","b","random","Math","timeout","round","max","pow","min","wrap","obj","methods","method","original","args","prototype","slice","call","callback","pop","bind","_originalTimeouts","JSON","parse","stringify","_timeouts","_options","_maxRetryTime","_fn","_errors","_attempts","_operationTimeout","_operationTimeoutCb","_timeout","_operationStart","_timer","_cachedTimeouts","reset","stop","currentTime","getTime","unshift","shift","undefined","splice","self","timeoutOps","cb","try","console","log","start","errors","attempts","counts","mainErrorCount","error","message","count","constructor","isBuffer","Readable","toWeb","fetch","globalThis","supportsNewBlobFromArrayBuffer","helloAsArrayBuffer","Uint8Array","Blob","text","_unused","toReadableStream","value","ReadableStream","stream","isNodeJsReadableStream","streamValue","s","ArrayBuffer","isNodeJsBuffer","TextEncoder","encode","controller","enqueue","close","pipe","readable","_read","_readableState","parseRegExp","map","kb","mb","gb","tb","pb","bytes","isNaN","results","exec","floatValue","unit","res","unitMatch","parseFloat","toLowerCase","parseInt","floor","BlobError","super","isPlainObject","Object","getPrototypeOf","Symbol","toStringTag","iterator","disallowedPathnameCharacters","supportsRequestStreams","navigator","product","process","type","versions","node","isNodeProcess","getApiUrl","startsWith","duplexAccessed","hasContentType","Request","body","duplex","headers","has","pathname","baseUrl","VERCEL_BLOB_API_URL","NEXT_PUBLIC_VERCEL_BLOB_API_URL","_unused2","TEXT_ENCODER","computeBodyLength","byteLength","size","isReadableStream","objectToString","toString","errorMessages","Set","isNetworkError","name","stack","_a","_b","debugIsActive","DEBUG","includes","NEXT_PUBLIC_DEBUG","debug","_a2","hasFetch","hasFetchWithUploadProgress","blobFetch","async","input","init","onUploadProgress","_ref","loaded","chunkTransformStream","createChunkTransformStream","chunkSize","onProgress","buffer","TransformStream","transform","chunk","queueMicrotask","newBuffer","set","newChunk","flush","newLoaded","pipeThrough","_objectSpread","hasXhr","XMLHttpRequest","blobXhr","_ref2","Response","blob","xhr","open","upload","addEventListener","event","lengthComputable","onload","_a3","signal","aborted","DOMException","Headers","getAllResponseHeaders","trim","split","forEach","line","parts","join","response","status","statusText","onerror","ontimeout","onabort","setRequestHeader","abort","send","DOMException2","atob","BlobAccessError","BlobContentTypeNotAllowedError","BlobPathnameMismatchError","BlobClientTokenExpiredError","BlobFileTooLargeError","BlobStoreNotFoundError","BlobStoreSuspendedError","BlobUnknownError","BlobNotFoundError","BlobServiceNotAvailable","BlobServiceRateLimited","seconds","retryAfter","BlobRequestAbortedError","getRetries","VERCEL_BLOB_RETRIES","_unused4","getBlobError","_b2","_c","code","data","json","_unused5","get","createBlobServiceRateLimited","requestApi","commandOptions","apiVersion","versionOverride","VERCEL_BLOB_API_VERSION_OVERRIDE","NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE","_unused3","getApiVersion","token","BLOB_READ_WRITE_TOKEN","getTokenFromOptionsOrEnv","extraHeaders","VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API","NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API","_unused6","getProxyThroughAlternativeApiHeaderFromEnv","storeId","requestId","retryCount","bodyLength","totalLoaded","sendBodyLength","VERCEL_BLOB_USE_X_CONTENT_LENGTH","_unused7","shouldUseXContentLength","total","percentage","apiResponse","_ref3","blobRequest","String","authorization","Number","toFixed","error2","ok","putOptionHeaderMap","createPutHeaders","allowedOptions","contentType","addRandomSuffix","allowOverwrite","cacheControlMaxAge","createPutOptions","_ref4","extraChecks","getToken","invalidCharacter","access","completeMultipartUpload","_ref6","uploadId","params","URLSearchParams","encodeURIComponent","abortSignal","createMultipartUpload","uploadPart","_ref9","internalAbortController","AbortController","part","responsePromise","partNumber","handleAbort","removeEventListener","maxConcurrentUploads","window","partSizeInBytes","maxBytesInMemory","uncontrolledMultipartUpload","optionsWithoutOnUploadProgress","createMultipartUploadResponse","totalToLoad","_ref0","partsToUpload","completedParts","reader","getReader","activeUploads","reading","currentPartNumber","rejected","currentBytesInMemory","doneReading","bytesSent","arrayBuffers","currentPartBytesRead","totalLoadedPerPartNumber","read","done","sendParts","valueOffset","remainingPartSize","endOffset","cancel","sendPart","uploadProgressForPart","completedPart","etag","releaseLock","partToSend","throttle","values","reduce","acc","cur","uploadAllParts","put","_ref1","optionsInput","multipart","throttle2","url","downloadUrl","contentDisposition","createPutMethod","_ref7","createCreateMultipartUploadMethod","_ref10","createCreateMultipartUploaderMethod","_ref8","createUploadPartMethod","_ref5","createCompleteMultipartUploadMethod"],"sourceRoot":""}